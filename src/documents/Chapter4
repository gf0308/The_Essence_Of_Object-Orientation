['객체지향의 사실과 오해' 학습 내용 정리]

4장 : 역할, 책임, 협력

 인간 세계에서 사람의 어떤 행동이 '적절한' 지 결정하는 것은, 그 장소/시간/상황 과 같은 문맥(context) 이다.
 문맥에 따라 사람의 행동이 적절한 행동인가 결정되어 진다.

 인간세계와 마찬가지로 객체의 세계에서도 문맥(context)에 의해 행동이 적절한가가 결정이 되어진다.
 객체의 세계에서 객체의 행동 방식을 결정하는 것은 '협력' 이라는 문맥(context) 이다.
  - 중요한 것은 개별 객체가 아니라 객체들 사이에 이뤄지는 협력
  - 객체지향 설계의 전체적 품질을 결정하는 것은 개별 객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 협력의 품질
  - 훌륭한 객체지향 설계는 객체들 간의 요청과 응답속에서 창발하는 '협력에 초점을 맞춰 애플리케이션을 설계하는 것'
  - 협력이 자리를 잡으면 저절로 객체의 행동이 드러나고, 뒤이어 적절한 객체의 상태도 결정됨
    (객체가 어떻게 행동해야 하는지 자연스럽게 드러남)  (해당 행위를 수행하기 위해 갖고있어야 할 데이터(상태)도 결정됨)

 # 객체의 모양을 빚는 것은 객체가 참여하는 협력이다
  - '어떤 협력에 참여하는지' 가 객체에 필요한 행동을 결정
  - '필요한 행동' 이 객체의 상태(데이터)를 결정

  => 개별적인 객체의 행동/상태가 아니라 객체들 간의 '협력' 에 집중할 것






 ▣ 객체의 모양을 결정하는 협력

  ■ 흔한 오류
   1. 객체는 시스템에 필요한 데이터를 저장하기 위해 존재한다는 선입견을 가지고 있는 경우가 많다.
     : 객체가 상태의 일부로 데이터를 포함하는 것은 사실이지만, 데이터는 단지 객체가 '행위' 를 수행하는데 쓰이는 재료일 뿐이다.
       "객체가 존재하는 이유는 행위를 수행하며 협력에 참여하기 위해서다."
       -> 중요한 것은 객체의 행동(책임) 이다.
   2. 객체지향에서 '클래스' 객체지향의 핵심 포인트라고 보는 경우가 많다. 즉 마치 객체지향언어는 클래스기반으로 된 언어인 줄로 생각하는 경우가 많다.
     : 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 구현 매커니즘 (구현 방식/도구)일 뿐이다.
       좀더 구체적으로 말하면 객체의 '타입' 을 '구현' 하기 위한 프로그래밍적 구현방식 일 뿐이며, 동시에 코드의 재사용이라는 효과도 얻기 위한 수단인 것이다.

     => 객체지향의 '핵심' 은, 객체 안에 담겨 있는 데이터값도, 객체의 타입이 되는 클래스도 아닌, 애플리케이션의 기능이란 목표를 위한 '협력' 안에서,
        이를 달성하기 위해 각 객체들이 자기에 맞는 '역할' 과 그에 따른 '책임' 을 맡고 자율적으로 동시에 협력적으로 작업을 수행해 협력을 달성해간다는 것이다.

        * ============================================================================================
          객체지향에서 객체는 독립적이지 않다.
          구체적으로 말하면 객체 자신의 존재이유는 독립적으로 놀거나 스스로 단지 존재하기 위함이 아닌,
          프로그램의 목표를 달성하기 위해 자신의 역할을 수행하기 위함이다.
          즉, 객체는 프로그램의 목표를 달성하기 위해 '협력' 에 잘 참여하고 자기 역할을 잘 수행한다는 것이 지상과제이며, 존재이유인,
          태생적으로 '협력' 과 '애플리케이션의 목적' 에 그 삶의 이유가 종속되어 있는 존재다.
          이에 잘 부합할 때, 객체를 '적절하다' 고 한다.
          객체는 종속적이며, 협력적이고, 사회적이다.
          객체는 섬이 아니다.
        ============================================================================================ *


  # 객체지향의 객체 설계 프로세스
  1. '협력' 고민
   - 무슨 시나리오인 것인가?
   - 이 시나리오를 위해 무슨 협력이 이뤄져야 하나?
   - 이 협력을 달성하기 위해 무슨 무슨 행동(책임)들이 있어야 하나?

  2. '책임' 고민
   - 이러한 책임(행위)을 수행하는 객체들은 무엇이겠는가?
    (위 사안을 다 정의하고 나면 => '객체들이 주고받을 요청/응답의 흐름' 이 나옴 => 이는 외부에 제공할 '행동'(공용 인터페이스) 이 됨)

  3. '데이터' 고민
   - (앞에서 정의된) 행동을 수행하는데 갖고 있어야 하는 필요한 데이터(상태)는 무엇인가? => 데이터와 행동이 어느정도 정의 됨

  4. '클래스' 고민
   - 위에서 정의된 행동과 데이터를 가진 클래스의 구현 방법을 고민


▣ 객체지향 설계 기법

 객체지향 애플리케이션 설계기법
  : 역할, 책임, 협력의 관점에서 객체지향 설계를 하는 3가지 기법이 있다.
   - 책임-주도 설계(Responsibility-Driven Design)
   - 디자인 패턴(Design Pattern)
   - 테스트-주도 개발(Test-Driven Development)

  1. 책임-주도 설계(Responsibility-Driven Design)
   : '협력'에 필요한 '책임'들을 '식별'하고 이 책임에 적합한 '객체'에게 '책임을 할당'하는 방식으로 애플리케이션을 설계하는 것
   -> 이에 따라 설계를 할 때 자연스럽게 흘러가는 사고의 흐름 : "무슨 협력이 일어나고, 무슨 역할들이 존재하며, 각 역할 별 책임은 무엇이 되지? 그리고 이 책임을 질 객체는 무엇으로 하지?"

  2. 디자인 패턴(Design Pattern)
   : 한마디로 하면 전문가들이 반복적으로 사용하는 해결방법을 정의해놓은 '설계 템플릿의 모음'
     -> 패턴은 전문가들이 특정 문제를 해결하기 위해 '이미 식별해놓은 역할, 책임, 협력의 모음' 인 것이다.
       (특정 디자인 패턴을 채택해서 그 패턴대로 개발을 하면, 그 디자인 패턴이 이미 갖고(보유하고) 있는 '협력','역할','책임' 을 바로 이용할 수 있다)

  3. 테스트-주도 개발(Test-Driven Development)
   : 한마디로 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식
    - 테스트주도개발은 '테스트가 아니라 설계를 위한 기법' 이다.
    - TDD의 핵심은 테스트 작성이 아니다,
      핵심은 '구체적인 코드를 작성해나가면서 역할, 책임, 협력을 식별'하고, '식별된 역할, 책임, 협력이 적절한지 (테스트를 하면서) 피드백받는 것' 이다.
      




['객체지향의 사실과 오해' 학습 내용 정리]

5장: 책임과 메시지

 1964년 두 명의 심리학자 존 달리(John Darley)와 밥 라타네(Bob Latane) 가 뉴욕대학생들을 대상으로 '책임감' 관련한 한 실험을 수행했다.
 여러 학생들이 한 학생의 이야기를 마이크로폰으로 듣고 있다가 갑자기 그 학생이 발작을 일으키는 소리가 들려올 경우
 얼마나 많은 학생들이 그 학생을 돕기 위해 외부에 도움을 요청했는지를 확인한 실험이었다.
 => 여러 사람들이 같이 듣고 있다고 여긴 경우에는, 외부에 도움을 요청한 비율이 31%밖에 되지 않았었다.
    자신말고도 또 도움을 요청할 사람이 있을 것이란 '책임감 분산(diffusion of responsibility)'이 발생했기에 발생한 일이었다.
 => 이는 '명확한 책임' 을 가진 권위자가 없을 때 어떤 일이 벌어지는 지를 잘 보여준다.

 객체의 세계도 마찬가지다. 객체들의 협력에는 '명확한 책임' 과 '역할' 을 지닌 객체들이 참여해야 한다.
 훌륭한 객체지향의 세계는 명확하게 정의된 역할과 책임을 지닌 객체들이 상호협력하는 세계다.


▣ 자율적인 책임
 ■ 설계의 품질을 좌우하는 책임
 ■ 자신의 의지에 따라 증언할 수 있는 자유
 ■ 너무 추상적인 책임
 ■ '어떻게' 가 아니라 '무엇' 을
 ■ 책임을 자극하는 메시지


▣ 메시지와 메서드
 ■ 메시지
 ■ 메서드

 ■ 다형성
  □ 다형성의 정의
  : 어떤 객체(메시지송신 객체)가 메시지를 송신할 때,
    이 '한 메시지(책임수행요청)' 을 서로 다른(다른 타입의) 객체들이 수신(이해) 할 수도 있고,
    그럴 때 각자만의 서로 다른 방식으로 처리하되 수행 결과는 동일하게[송신객체가 원하는 결과] 만들어내고
    송신객체가 이를 얻을 수 있는 특징이다.

  □ '다형성' 개념 이해의 핵심 포인트
   : 다형성에서 중요한 것은 '메시지 송신자의 관점' 임.
    - 메시지를 송신한 객체들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도,
      책임을 정상적으로 잘 수행해내기만 한다면 송신객체 입장에서는 서로 다른 타입이든 다른 방식으로 처리하든 아무 상관이 없음.
    - 그러므로 이 (다형적인) 객체들을 송신자는 구분할 필요가 없고, 모두 동일하게 봄
    -> 한 책임을 수행시키고자 할 때, 다양한 타입의 객체들을 활용 가능하다는 특징 => '다형성(Polymorphism)'
      (송신객체 관점 에서)           (다형적인)

  □ 다형성이 암시하는 의미
   : 객체들 간의 '대체가능성'
   다형성은 동일 역할을 수행할 수 있는 객체들 사이에 '대체가능성'이 존재한다는 것을 의미한다.
   - 메시지 송신객체 입장에선 동일 메시지를 처리할 수만 있다면 그 담당객체가 A 타입이든, B 타입이든, a 메서드를 통하든 b 메서드를 통하든 알바 아님.
   - 송신자 입장에선 그 역할(책임)을 수행할 수 있기만 하면 됨
    => 그 협력 내에서 객체들은 대체가능한 존재인 것

  □ 다형성의 효과
  : 다형성은 객체들의 대체 가능성을 이용해 '설계를 유연' 하고 '재사용 가능' 하게 만든다
    - 송신객체는 수신객체의 종류(타입)을 모르더라도 메시지(책임수행요청)를 전송할 수 있다 (-> 즉 여러 종류 객체에게 책임수행요청을 보낼 수 있는 것)
    - 다형성은 수신자의 종류를 캡슐화 하고 있다.
      (송신객체 입장에선 수신자 종류를 알 필요 없게 만든다는 면에서)

  □ 다형성이 ('다형성' 이란 법칙) 달성될 수 있었던 원인**
  : 객체지향 패러다임은
    송신객체와 수신객체 간의 결합도를 결정하는 요인을
    '객체타입' 에서 '메시지' 로 바꿨다.
     => 결합도가 확연히 낮아지게 되는 결과
       (객체타입이 뭐냐는 하나도 상관없이, 해당메시지를 이해하고 처리할 수 있느냐만 관건이 됨)

    다시말하면,
    : 송신객체-수신객체 간 결합도(decided by 객체 타입) --> 송신객체-수신객체 간 결합도(decided by 메시지)
     로 바꿔 버림
     -> (보다 추상화되어진 결합도..?)
     -> 결합도 낮아짐

  이렇게 된 결과, 객체는 메시지를 이해할 수 있는 어떤 객체와도 협력이 가능해졌고 그 결과 프로그래머는 유연하고 확장가능한 구조를 만들 수 있게 됨
  -> '객체지향 패러다임이 강력한 이유 (다형성을 이용해 협력을 유연하게 만들 수 있는것)''
                                                * 애플리케이션을 구성하는 객체의 협력이 유연해진다
                                                  = 애플리케이션이 추가/변경/유지보수에 용이해진다
                                                   = 엄청난 강력함


 ■ 유연하고 확장 가능하고 재사용성이 높은 협력의 의미
  : 훌륭한 설계 품질(Design Quality)

  위에서 언급하는 '송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실' 이 중요한 이유는
  -> '설계의 품질' 에 큰 benefit 을 주기 때문이다.
   1) "협력이 유연해짐"
     - 송신객체는 수신객체가 메시지를 이해하기만 한다면 누구라도 상관 안함
     - 수신객체가 어떤 타입인지 알지도 신경쓰지도 않기 때문에 다른 타입의 객체로 교체해도 송신자에겐 아무 영향 X
      -> 송신자에 대한 파급효과 없이 유연하게 (객체 간) 협력 변경 가능
   2) "협력이 수행되는 방식 확장 가능"
     - 송신객체에 대한 파급효과는 전무하게 수신객체를 변경할 수 있기 때문에 세부적인 수행방식을 쉽게 수정 가능
       : 협력을 확장하고 싶으면 그를 위한 객체(새로운 유형의 객체)로 끼워맞추기(교체)만 하면 됨
   3) "협력이 수행되는 방식 재사용 가능"
     - 전체 기능인 '협력' 에 영향을 미치지 않고서도 다양한 객체들이 수신객체로서 활동할 수 있기 때문에,
       다양한 문맥(상황)에서도 이 '협력' 을 재사용 가능함
       (: 이 협력의 구도와 호환되는 어떠한 상황에서 전체의 큰 틀은 유지한 채 세부적인 기능의 객체만 교체해서 구동시키면 -> 그 문맥을 위한 '협력' 으로 재탄생하게 됨!)

        <객체지향 시스템의 특징(Freeman 2009)>
        "객체지향 시스템은 협력하는 객체들의 연결망(web) 이다."
         - 시스템: 시스템은 객체를 생성하고 상호 간에 메시지를 송신할 수 있게 이들을 끼워 맞춤으로써 구축된다
         - 시스템의 행위: 시스템의 행위는 객체들의 조합으로 창발되는 속성인 것
         - 객체들의 조합: 객체와 객체들이 어떻게 연결되는지에 대한 선택 (프로그래머를 통해 프로그래밍 된 연결관계)
          => "이것은 '객체의 조합을 변경'하기만 하면 '시스템의 행위를 변경'시킬 수 있다는 것을 의미한다."
            - 객체들을 조합시킨 코드: 객체의 조합을 관리하기 위해 작성하는 코드는 객체 연결망이 어떻게 행동할것인지에 대한 '선언적인 정의'
            - 객체가 '무엇을' 할것인지에 초점: 객체가 어떻게 할 것인지보다는 무엇을 할 것인지에 초점을 맞추기 떄문에 시스템의 행위를 변경하기 쉬움.


 ■ 송신자와 수신자를 약하게 연결하는(낮은 결합도를 갖게 하는) 메시지


▣ 메시지를 따라라
 ■ 객체지향의 핵심, 메시지
 ■ 책임-주도 설계 다시 살펴보기
 ■ What/Who 사이클
 ■ 묻지 말고 시켜라(Tell, Don't Ask)
 ■ 메시지를 믿어라

 ▣ 객체 인터페이스
  ■ 인터페이스
   인터페이스는 '무엇인가를 하기 위해 사용하는 도구[수단]' 이다.

   □ 인터페이스의 세가지 특징
    1. 인터페이스는 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있음
    2. 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동방식을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않음.
    3. (상호작용하는)대상이 변경되더라도, 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용할 수 있음.

        * 프로그래밍 하는데 사용하는 대표적인 인터페이스 : API
          애플리케이션 프로그래밍 인터페이스, 즉 API 는 말 그대로 애플리케이션 개발(프로그래밍) 하는데 사용하는 도구 (기능 조각)다.
          이 API 들은 하나 하나 조각처럼 가져다 사용해 기능을 조합해 만듬으로써 기능을 완성하는데에 이용되는 것이다.

  ■ 메시지가 인터페이스를 결정한다

  ■ 공용 인터페이스

  ■ 책임, 메시지, 그리고 인터페이스

   □지금까지의 객체의 특징 정리
    *객체의 책임은 자율적이어야 한다(즉 수행방법(메서드)을 자유롭게 선택할 수 있어야 한다)
    *객체와 객체 간 유일한 의사소통 수단은 '메시지' 다.
    *메시지는 결국 객체의 인터페이스를 구성한다 (즉, 한 객체가 수신하는 메시지 내용들이 그 객체가 수행할 책임들이며, 외부에 제공할 인터페이스다)
    *객체가 메시지를 수신했을 때 수행하는 행동이 그 객체의 행동이다.
    *객체가 책임을 수행하는 방법이 메서드다. 객체는 메서드를 선태갷서 수행할 수 있다.
    *'메시지와 메서드의 분리' 는 객체를 외부와 내부라는 두 개의 명확하게 분리된 영역으로 구분한다,
      동시에 다형성을 통해 다양한 타입의 객체를 이용할 수 있게 한다.


 ▣ 인터페이스와 구현의 분리

  ■ 객체 관점에서 생각하는 방법




 ▣ 책임의 자율성이 협력의 품질을 결정한다

   *책임의 자율성: 객체가 책임을 수행할 때 책임을 수행하는 방식(메서드)을 스스로 결정할 수 있는 것

  ■ '책임이 자율적인 협력' 이 '책임이 자율적이지 않은 협력' 보다 이해하기 쉽고 변경에 유연하다.
   - 객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 된다.
   - 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 된다.

  ■ 책임이 자율적인 협력이 이해하기 쉽고 변경에 유연한 이유
   1. 자율적인 책임은 협력을 단순하게 만든다.
    - 자율적인 책임은 (단순하면서도) 의도를 명확하게 표현함 -> 협력을 단순하게 이해하기 쉽게 만든다
      (ex: "증언하라" : 이 한마디면, 어떤 방식으로 내용을 전달할지(글로쓴다던가, 말로한다던가, 손짓발짓으로 한다던가 등) 상관없이 '내용을 증언하는것' 자체만 충족시키면 되므로, 가장 적절한 방식을 알아서 선택해서 사용할 수 있음)

   2. 자율적인 책임은 객체의 외부와 내부를 명확하게 분리하게 한다. (객체의 내-외부가 명확히 분리되는 것이 가능하게 함)
    - '자율적 책임' 은 메시지 송신객체 입장에선 (수신객체가 수행방법은 어떻게 하든지) 원하는 결과만 받을 수 있으면 되는 것
      -> 책임수행방법에 대해선 송신객체는 알바가 아님 -> 공용 인터페이스만 관심사항이고, 내부 구현은 관심이 없음
      -> 송신객체의 내부 구현은 외부로부터의 어떤 영향도 없음 -> 공용 인터페이스 상에 정의된 결과만 돌려주기만 하면, 내부 구현은 전적으로 송신객체만의 권한이 됨
      -> 객체의 외부-내부가 완벽하게 분리될 수 있음.
    - 이는 (객체지향 커뮤니티 전문용어로) 다음과 같이 표현 가능
     : "요청하는 객체가 몰라도 되는 사적인 부분이 객체 내부로 '캡슐화'되기 때문에, 인터페이스와 구현이 분리된다."
    - 객체 내-외부의 분리[인터페이스와 구현의 분리] 는 훌륭한 객체지향 설계를 구분하는 가장 중요한 기반임.

   3. 책임이 자율적일 경우, 책임을 수행하는 내부적인 방법(내부 구현)을 변경하더라도 외부에 영향을 미치지 않는다.
    - 2번의 내용처럼, 책임이 자율적이면 송신객체 입장에선 돌아오는 결과물만 제대로 받으면 그만이므로, 객체 내부의 구체적인 수행방식은 알 필요가 없음
     -> 수신 객체의 내부적인 구현방법은 수신객체가 마음대로 변경 가능; 변경하더라도 외부에 영향 없음
    - 책임이 자율적일수록 (내부 구현이 변경되더라도) 변경에 의해 수정돼야 하는 범위가 좁아지고 명확해진다.
    - 이는 (객체지향 커뮤니티 전문용어로) 다음과 같이 표현 가능
     : "변경의 파급효과가 객체 내부로 캡슐화되기 때문에 두 객체 간의 결합도가 낮아진다."

   4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.
    - 자율적인 책임은 (그 책임을 어떻게 수행할 것인지 방식은 상관없이) 그 책임을 결과적으로 수행해낼 수 있기만 하면,
      어떤 객체도 대신 수행할 수 있음 -> 다양한 객체들이 협력의 대상이 될 수 있음
    - 만약 '책임을 수행하는 방법'이 결정되어 있었다면, 이를 동시에 만족시킬 수 있는 객체의 수는 훨씬 줄어들 것이고,
      그에 따라 협력 대상이 될 수 있는 객체들은 더 적어지게 될 것임.
    - 하지만 그런 제약 없이 올바른 결과만 주면 되는 '자율적인 책임'이라면, 굉장히 다양한 객체들을 수용할 수 있게 된다.
    - 이는 (객체지향 커뮤니티 전문용어로) 다음과 같이 표현 가능
     : "설계가 유연해지고 재사용성이 높아진다."

   5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.
    - 객체가 수행하는 책임들이 자율적이면 자율적일수록 객체의 존재 이유가 명확하게 표현된다.
      왜냐하면 객체는 동일한 목적을 달성하기 위한, 강하게 연관된 책임들로 구성되기 때문이다.
      ex) 자율적 책임과 비자율적 책임 직접 비교
        --자율적 책임(적당히 추상적): '증인석에 입장하다','증언하다' ... (a)
        --비자율적 책임(불필요하게 구체적): '증인석에 종종걸음으로 입장하다', '글로 작성한 증언문을 낭독하다' ... (b)
        (a)의 경우는 단지 '증인석에 입장하다','증언하다'란 간단하고 명확한 책임 2개로, 이 객체가 '증인'으로서 증언하기 위한 객체라는 것을 알 수 있음
        (b)의 경우는 '증인석에 종종걸음으로 입장하다', '글로 작성한 증언문을 낭독하다' 식으로 불필요하게 구체적인 세부사항으로 인해 (a)에 비해 객체의 정체를 파악하는데 오래걸림.
    - 이는 (객체지향 커뮤니티 전문용어로) 다음과 같이 표현 가능
     : "책임이 자율적일수록 객체의 응집도를 높은 상태로 유지하기 쉬워진다"


   ※ 정리
    책임이 자율적일수록
    - 적절하게 '추상화' 되고
    - 응집도가 높아지고
    - 결합도가 낮아지며
    - 캡슐화가 증진되고
    - 인터페이스와 구현이 명확히 분리되며
    - 설계의 유연성과 재사용성 향상된다.

   객체지향의 강력함을 누리기 위한 출발점은 '책임을 자율적으로' 만드는 것이다.
   그리고 이것은 이를 위해 선택하는 '메시지'에 따라 달라진다 (-> '자율적인 책임' is from '자율적인 메시지' )









